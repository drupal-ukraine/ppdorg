<?php

/**
 * @file
 * Drupal.org statistics routines.
 */

define('PPGETSTAT_USER_NODE_TYPE', 'user');
// Number of users queued to be scanned per cron run.
define('PPGETSTAT_STATSJOBS_PROCESS_NUMBER', 10);
// Number of calls to drupal.org per cron run.
define('PPGETSTAT_DORGSCRAPPING_PROCESS_NUMBER', 20);
// If no stats available we scan commits for last half a year.
define('PPGETSTAT_DEFAULT_TIME_PERIOD_FOR_SCANNING', 6 * 30 * 24 * 60 * 60);
// We group statistics per week.
define('PPGETSTAT_TIME_PERIOD_GRANULARITY', 7 * 24 * 60 * 60);
/**
 * Implements hook_menu().
 */
function ppgetstat_menu() {
  $items['node/%node/commits'] = array(
    'title' => 'Commits',
    'description' => 'Commits statistics.',
    'page callback' => 'ppgetstat_commits_page',
    'page arguments' => array(1),
    'access callback' => 'ppgetstat_commits_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'ppgetstat.pages.inc',
  );
  $items['admin/config/services/ppgetstat'] = array(
    'title' => 'Get user profiles',
    'description' => 'PPgetstat settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ppgetstat_settings_form'),
    'access arguments' => array('administer site configuration'),
    'weight' => -21,
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/content/ppgetstat_import'] = array(
    'title' => 'Stats Import',
    'description' => 'Manual import drupal.org users data.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ppgetstat_import_form'),
    'access arguments' => array('administer nodes'),
    'weight' => -21,
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Module ppgetstat settings form.
 *
 * @param array $form
 *   Drupal form.
 *
 * @param array $form_state
 *   Drupal fomr state.
 *
 * @return mixed
 *   Settings form for ppgetstat module.
 */
function ppgetstat_settings_form($form, &$form_state) {
  $form['ppgetstat_users'] = array(
    '#type' => 'textarea',
    '#title' => t('Users list'),
    '#description' => 'Please enter comma separated list of nicks per user line. If user has more than one nick. New line - new user.',
    '#default_value' => variable_get('ppgetstat_users'),
  );
  $form['ppgetstat_pages_to_scan'] = array(
    '#type' => 'textfield',
    '#title' => t('Pages to scan at once at drupal.org'),
    '#description' => 'Please enter integer value here.',
    '#default_value' => variable_get('ppgetstat_pages_to_scan'),
  );

  return system_settings_form($form);
}

/**
 * Module ppgetstat content import form.
 *
 * @param array $form
 *   Drupal form.
 *
 * @param array $form_state
 *   Drupal form state.
 *
 * @return mixed
 *   Form for ppgetstat manual import.
 */
function ppgetstat_import_form($form, &$form_state) {
  $form['ppgetstat_types'] = array(
    '#type' => 'checkboxes',
    '#options' => drupal_map_assoc(array('commits', 'posts')),
    '#title' => t('drupal.org user\'s data'),
  );
  $form['ppgetstat_import'] = array(
    '#type' => 'submit',
    '#value' => t('Import drupal.org data'),
  );

  return $form;
}

/**
 * Module ppgetstat content import form submit handler.
 *
 * @param array $form
 *   Drupal form.
 *
 * @param array $form_state
 *   Drupal form state.
 */
function ppgetstat_import_form_submit($form, &$form_state) {
  // Reset counter for debug information.
  drupal_set_message('<pre>' . print_r($form_state['values'], TRUE) . '</pre>');

  // Grab commits in a batch.
  if ($form_state['values']['ppgetstat_types']['commits'] === 'commits') {
    $_SESSION['http_request_count'] = 0;
    $function = 'ppgetstat_batch_start';
    $batch = $function();
    batch_set($batch);
  }
}

/**
 * Prepare batch operations.
 *
 * @return array
 *   Array for commits batch routine.
 */
function ppgetstat_batch_start() {

  $user_ids = ppgetstat_get_user_ids();
  $num_operations = count($user_ids);
  drupal_set_message(t('Creating an array of @num operations', array('@num' => $num_operations)));

  $operations = array();
  // Set up an operations array with some elements, each doing its own function
  // Each operation in the operations array means at least one new HTTP request,
  // running Drupal from scratch to accomplish the operation. If the operation
  // returns with $context['finished'] != TRUE, then it will be called again.
  // In this example, $context['finished'] is always TRUE.
  foreach ($user_ids as $nick => $id_user) {
    $operations[] = array(
      'ppgetstat_batch_op_1',
      array(
        ppgetstat_dorg_request($id_user),
        t('(Get commits counter for user @nick)', array('@nick' => $nick)),
      ),
    );
  }

  $batch = array(
    'operations' => $operations,
    'finished' => 'ppgetstat_finished',
  );

  return $batch;
}

/**
 * Single function-wrapper to fetch commits and posts data for batch operations.
 *
 * @param array $user_data
 *   array(userid, username).
 *
 * @return array
 *   array(
 *     'user' => string,
 *     'commits' => int,
 *     'posts' => int,
 *     'nick' => string,
 *   )
 */
function ppgetstat_dorg_request($user_data) {
  $commits = ppgetstat_dorg_commits_request($user_data);
  $posts = ppgetstat_dorg_posts_request($user_data);
  drupal_set_message('<pre>' . print_r($posts, TRUE) . '</pre>');

  return array(
    'user' => $user_data[1],
    'commits' => $commits,
    'posts' => $posts,
    'nick' => $user_data[2],
  );
}

/**
 * Returns data for ppgetstat_batch_op_1($ret,...).
 *
 * @param array $id_user
 *   array(userid, username).
 *
 * @return int|string
 *   Commits number.
 */
function ppgetstat_dorg_commits_request($id_user) {
  // @todo Cache downloaded pages to filesystem: files/dorgpages/nodeid_week_year.html

  // Drupal.org commits counter selector: "div.item-list li.last"
  $qp = htmlqp('https://drupal.org/user/' . $id_user[0], 'div.item-list li.last');

  // "Total: XXX commits"
  $commits_text = $qp->text();
  $commits_data = explode(" ", $commits_text);

  drupal_set_message($id_user[1] . '`s commits count:' . $commits_data[1]);

  return $commits_data[1];
}

/**
 * Returns data for ppgetstat_batch_op_1($ret,...).
 *
 * @param array $id_user
 *   array(userid, username).
 *
 * @return array
 *   array(
 *     string => int, // post_type => posts count
 *   )
 */
function ppgetstat_dorg_posts_request($id_user) {
  $qp = htmlqp('https://drupal.org/user/' . $id_user[0] . '/track', '#content .content');
  $qp_clone = clone($qp);
  $page_number = 0;

  $post_count = array(
    'book_listing' => 0,
    'book_page' => 0,
    'case_study' => 0,
    'change_record' => 0,
    'distribution_project' => 0,
    'drupal_core' => 0,
    'drupal_org_project' => 0,
    'issue' => 0,
    'module_project' => 0,
    'organization' => 0,
    'release' => 0,
    'theme_engine_project' => 0,
    'theme_project' => 0,
  );

  while ($qp_clone->find('.pager-next')->size()) {
    ppgetstat_parse_posts_table($qp, $post_count);

    $qp = htmlqp('https://drupal.org/user/' . $id_user[0] . '/track?page=' . ++$page_number, '#content .content');
    $qp_clone = clone($qp);
  }

  ppgetstat_parse_posts_table($qp, $post_count);

  return $post_count;
}

/**
 * Iterate through the table rows and increase post types entries count according to the Post Type label.
 *
 * @param QueryPath $content
 *   Content of www.drupal.org/user/UID/track page wrapper with htmlqp.
 *
 * @param array $post_count
 *   array(
 *     string => int, // post_type => posts count
 *   )
 */
function ppgetstat_parse_posts_table(QueryPath $content, &$post_count) {
  foreach ($content->find('tbody tr') as $tr) {
    switch ($tr->find('td:first')->text()) {
      case 'Book listing':
        $post_count['book_listing']++;
        break;

      case 'Book page':
        $post_count['book_page']++;
        break;

      case 'Case study':
        $post_count['case_study']++;
        break;

      case 'Change record':
        $post_count['change_record']++;
        break;

      case 'Distribution project':
        $post_count['distribution_project']++;
        break;

      case 'Drupal core':
        $post_count['drupal_core']++;
        break;

      case 'Drupal.org project':
        $post_count['drupal_org_project']++;
        break;

      case 'Issue':
        $post_count['issue']++;
        break;

      case 'Module project':
        $post_count['module_project']++;
        break;

      case 'Organization':
        $post_count['organization']++;
        break;

      case 'Release':
        $post_count['release']++;
        break;

      case 'Theme Engine project':
        $post_count['theme_engine_project']++;
        break;

      case 'Theme project':
        $post_count['theme_project']++;
        break;
    }
  }
}

/**
 * Batch operation for ppgetstat_commits_batch_start: Save a user's node.
 *
 * This is the function that is called on each operation in ppgetstat_commits_batch_start.
 */
function ppgetstat_batch_op_1($ret, $operation_details, &$context) {
  // @todo Save stats to nodes here. User will be passed count(nicks) time.

  if (isset($ret['commits']) && isset($ret['user'])) {
    global $user;

    // Get node for current nick.
    $nid = ppgetstat_get_nid_by_nick($ret['nick']);
    $current_node = node_load($nid);

    $node = clone $current_node;
    unset($node->vid);
    $node->revision = TRUE;
    $node->revision_timestamp = time();

    // Save new revision only when something changed. Skipping saving otherwise.
    if ($ret['commits'] == $node->field_tracking[LANGUAGE_NONE][0]['value']) {
      // Store some results for post-processing in the 'finished' callback.
      // The contents of 'results' will be available as $results in the
      // 'finished' function (in this example, batch_example_finished()).
      $context['results'][] = $node->nid . ' : ' . check_plain($node->title);

      // Optional message displayed under the progressbar.
      $context['message'] = t(
          'Skipping saving user "@title"',
          array('@title' => $node->title)
        ) . ' ' . $operation_details;

      return;
    }
    // Counter changed, saving new revision.
    unset($node->field_tracking[LANGUAGE_NONE]);
    $node->field_tracking[LANGUAGE_NONE] = array();

    // Preparing properties for saving. Only commits here.
    $node->field_tracking[LANGUAGE_NONE][] = array(
      'ddorg_commits' => array(
        'category' => '',
        'name' => 'ddorg_commits',
        '_weight' => 0,
        'delete' => 'Delete',
        'properties' => array(
          'commit' => array(
            'category' => 'ddorg_commits',
            'attribute' => 'commit',
            'value' => $ret['commits'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
        ),
      ),
      'ddorg_posts_tracking' => array(
        'category' => '',
        'name' => 'ddorg_posts_tracking',
        '_weight' => 0,
        'delete' => 'Delete',
        'properties' => array(
          'book_listing' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'book_listing',
            'value' => $ret['posts']['book_listing'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'book_page' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'book_page',
            'value' => $ret['posts']['book_page'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'case_study' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'case_study',
            'value' => $ret['posts']['case_study'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'change_record' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'change_record',
            'value' => $ret['posts']['change_record'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'distribution_project' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'distribution_project',
            'value' => $ret['posts']['distribution_project'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'drupal_core' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'drupal_core',
            'value' => $ret['posts']['drupal_core'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'drupal_org_project' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'drupal_org_project',
            'value' => $ret['posts']['drupal_org_project'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'issue' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'issue',
            'value' => $ret['posts']['issue'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'module_project' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'module_project',
            'value' => $ret['posts']['module_project'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'organization' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'organization',
            'value' => $ret['posts']['organization'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'release' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'release',
            'value' => $ret['posts']['release'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'theme_engine_project' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'theme_engine_project',
            'value' => $ret['posts']['theme_engine_project'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
          'theme_project' => array(
            'category' => 'ddorg_posts_tracking',
            'attribute' => 'theme_project',
            'value' => $ret['posts']['theme_project'],
            '_weight' => 0,
            'delete' => 'Delete',
          ),
        ),
      ),
    );

    node_object_prepare($node);
    $node->validated = TRUE;
    $node->log = time();
    $node = node_submit($node);
    ppgetstat_node_save($node);

    // Store some results for post-processing in the 'finished' callback.
    // The contents of 'results' will be available as $results in the
    // 'finished' function (in this example, batch_example_finished()).
    $context['results'][] = $node->nid . ' : ' . check_plain($node->title);

    // Optional message displayed under the progressbar.
    $context['message'] = t('Saving node "@title"', array('@title' => $node->title)) . ' ' . $operation_details;
  }

  ppgetstat_update_http_requests();
}

/**
 * Utility function to increment HTTP requests in a session variable.
 */
function ppgetstat_update_http_requests() {
  $_SESSION['http_request_count']++;
}

/**
 * Utility function to count the HTTP requests in a session variable.
 *
 * @return int
 *   Number of requests.
 */
function ppgetstat_get_http_requests() {
  return !empty($_SESSION['http_request_count']) ? $_SESSION['http_request_count'] : 0;
}

/**
 * Batch 'finished' callback used by ppgetstat_commits_batch_start().
 */
function ppgetstat_finished($success, $results, $operations) {
  if ($success) {
    // Here we could do something meaningful with the results.
    // We just display the number of nodes we processed...
    drupal_set_message(
      t(
        '@count results processed in @requests HTTP requests.',
        array(
          '@count' => count($results),
          '@requests' => ppgetstat_get_http_requests()
        )
      )
    );
    drupal_set_message(t('The final node ID was "%final"', array('%final' => end($results))));
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    drupal_set_message(
      t(
        'An error occurred while processing @operation with arguments : @args',
        array(
          '@operation' => $error_operation[0],
          '@args' => print_r($error_operation[0], TRUE),
        )
      )
    );
  }
}

/**
 * Get list of user ids.
 *
 * @return array
 *   Returns array('nick1' => array(id1, user, nick1), 'nick2' => array(id2, user, nick2)).
 */
function ppgetstat_get_user_ids() {

  $ids = variable_get('ppgetstat_get_user_ids', array());
  if (!empty($ids)) {
    return $ids;
  }

  $users = ppgetstat_get_users();
  $ids = array();
  foreach ($users as $user => $nicks) {
    foreach ($nicks as $nick) {
      $ids[$nick] = array(
        ppgetstat_get_id_by_nick($nick),
        $user,
        $nick,
      );
    }
  }
  variable_set('ppgetstat_get_user_ids', $ids);

  return $ids;
}

/**
 * Get drupal.org user ID using nickname and http://dgo.to.
 *
 * @param string $nick
 *   Nickname.
 *
 * @return int
 *   Drupal.org user id.
 */
function ppgetstat_get_id_by_nick($nick) {
  if ($id_cached = cache_get('ppgetstat_nick_' . $nick)) {
    return $id_cached->data;
  }
  $nick_data = drupal_http_request('http://dgo.to/@' . $nick);
  $request = parse_url($nick_data->redirect_url);
  $id_data = explode("/", $request['path']);
  $id = $id_data[2];
  cache_set('ppgetstat_nick_' . $nick, $id);

  return $id;
}

/**
 * Get associated array of users entered in settings.
 *
 * @return array
 *   Users array('user1' => array('user1_nick1', 'user1_nick2'), 'user2' => array('user2_nick)).
 */
function ppgetstat_get_users() {
  $users = variable_get('ppgetstat_users');
  $allusers = array();
  foreach (preg_split("/((\r?\n)|(\r\n?))/", $users) as $user_line) {
    $nicks = explode(',', $user_line);
    if (isset($nicks[0])) {
      $allusers[$nicks[0]] = $nicks;
    }
  }

  return $allusers;
}

/**
 * Getting node ID by nickname. If node not yet available, creates one and returns it's node ID.
 *
 * @param string $nick
 *   Nickname from drupal.org for searching.
 *
 * @return int
 *   Returns node ID.
 */
function ppgetstat_get_nid_by_nick($nick) {
  $query = db_select('node', 'n');
  $query = $query->fields('n', array('nid'));
  $query = $query->condition('type', 'user');
  $query = $query->condition('title', $nick);
  $query = $query->execute();

  $result = $query->fetchAll();
  $nid = FALSE;
  if (isset($result[0]) && isset($result[0]->nid)) {
    $nid = $result[0]->nid;
  }
  // Node was found.
  if ($nid !== FALSE) {
    return $nid;
  }

  // Creating new user's node.
  global $user;
  $node = new stdClass();
  $node->title = $nick;
  // @todo move this to config.
  $node->type = 'user';
  node_object_prepare($node);
  $node->language = LANGUAGE_NONE;
  $node->uid = $user->uid;
  $node->created = time();
  $node->changed = $node->created;
  $node->timestamp = $node->created;
  $node->status = 1;
  $node->is_new = TRUE;
  $node->revision = TRUE;
  $node->validated = TRUE;
  $node->log = 'initial revision for nick: ' . $nick;
  $node = node_submit($node);
  ppgetstat_node_save($node);

  return ppgetstat_get_nid_by_nick($nick);
}

/**
 * Saves changes to a node or adds a new node. Created for ability to save custom timestamps.
 *
 * @param object $node
 *   The $node object to be saved. If $node->nid is
 *   omitted (or $node->is_new is TRUE), a new node will be added.
 */
function ppgetstat_node_save($node) {
  $transaction = db_transaction();

  try {
    // Load the stored entity, if any.
    if (!empty($node->nid) && !isset($node->original)) {
      $node->original = entity_load_unchanged('node', $node->nid);
    }

    field_attach_presave('node', $node);
    global $user;

    // Determine if we will be inserting a new node.
    if (!isset($node->is_new)) {
      $node->is_new = empty($node->nid);
    }

    // Set the timestamp fields.
    if (empty($node->created)) {
      $node->created = REQUEST_TIME;
    }
    // The changed timestamp is always updated for bookkeeping purposes,
    // for example: revisions, searching, etc.

    // This is the diff with core node_save. We should be able save custom time.
    // $node->changed = REQUEST_TIME;
    // $node->timestamp = REQUEST_TIME;
    if (empty($node->changed)) {
      $node->changed = REQUEST_TIME;
    }
    if (empty($node->timestamp)) {
      $node->timestamp = REQUEST_TIME;
    }
    $update_node = TRUE;

    // Let modules modify the node before it is saved to the database.
    module_invoke_all('node_presave', $node);
    module_invoke_all('entity_presave', $node, 'node');

    if ($node->is_new || !empty($node->revision)) {
      // When inserting either a new node or a new node revision, $node->log
      // must be set because {node_revision}.log is a text column and therefore
      // cannot have a default value. However, it might not be set at this
      // point (for example, if the user submitting a node form does not have
      // permission to create revisions), so we ensure that it is at least an
      // empty string in that case.
      // @todo: Make the {node_revision}.log column nullable so that we can
      // remove this check.
      if (!isset($node->log)) {
        $node->log = '';
      }
    }
    elseif (!isset($node->log) || $node->log === '') {
      // If we are updating an existing node without adding a new revision, we
      // need to make sure $node->log is unset whenever it is empty. As long as
      // $node->log is unset, drupal_write_record() will not attempt to update
      // the existing database column when re-saving the revision; therefore,
      // this code allows us to avoid clobbering an existing log entry with an
      // empty one.
      unset($node->log);
    }

    // When saving a new node revision, unset any existing $node->vid so as to
    // ensure that a new revision will actually be created, then store the old
    // revision ID in a separate property for use by node hook implementations.
    if (!$node->is_new && !empty($node->revision) && $node->vid) {
      $node->old_vid = $node->vid;
      unset($node->vid);
    }

    // Save the node and node revision.
    if ($node->is_new) {
      // For new nodes, save new records for both the node itself and the node
      // revision.
      drupal_write_record('node', $node);
      _node_save_revision($node, $user->uid);
      $op = 'insert';
    }
    else {
      // For existing nodes, update the node record which matches the value of
      // $node->nid.
      drupal_write_record('node', $node, 'nid');
      // Then, if a new node revision was requested, save a new record for
      // that; otherwise, update the node revision record which matches the
      // value of $node->vid.
      if (!empty($node->revision)) {
        _node_save_revision($node, $user->uid);
      }
      else {
        _node_save_revision($node, $user->uid, 'vid');
        $update_node = FALSE;
      }
      $op = 'update';
    }
    if ($update_node) {
      db_update('node')
        ->fields(array('vid' => $node->vid))
        ->condition('nid', $node->nid)
        ->execute();
    }

    // Call the node specific callback (if any). This can be
    // node_invoke($node, 'insert') or
    // node_invoke($node, 'update').
    node_invoke($node, $op);

    // Save fields.
    $function = "field_attach_$op";
    $function('node', $node);

    module_invoke_all('node_' . $op, $node);
    module_invoke_all('entity_' . $op, $node, 'node');

    // Update the node access table for this node.
    node_access_acquire_grants($node);

    // Clear internal properties.
    unset($node->is_new);
    unset($node->original);
    // Clear the static loading cache.
    entity_get_controller('node')->resetCache(array($node->nid));

    // Ignore slave server temporarily to give time for the
    // saved node to be propagated to the slave.
    db_ignore_slave();
  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('node', $e);
    throw $e;
  }
}

/**
 * Implements hook_cron().
 */
function ppgetstat_cron() {

  // Create items in stats_jobs queue.
  _ppgetstat_cron_createItem_stats_jobs();

  // Process items from stats_jobs queue.
  _ppgetstat_cron_processItem_stats_jobs();

  // Process items from stats_jobs queue.
  _ppgetstat_cron_processItem_dorg_scrapping_jobs();
}

/**
 * If period has passed, scan each user's commits.
 */
function _ppgetstat_cron_createItem_stats_jobs() {
  $last_cron_run = variable_get('ppgetstat_last_statsjobs_timestamp');

  if ($last_cron_run > REQUEST_TIME - 24 * 60 * 60) {
    return;
  }

  $queue = DrupalQueue::get('stats_jobs');
  foreach (_ppgetstats_get_all_users() as $user_node) {
    if (!isset($user_node->field_user_id[LANGUAGE_NONE][0]['value'])) {
      continue;
    }
    $doid = $user_node->field_user_id[LANGUAGE_NONE][0]['value'];
    $last_scan = db_query('SELECT timestamp FROM {ppgetstat_commits} WHERE doid = :doid ORDER BY timestamp DESC LIMIT 1',
      array(':doid' => $doid)
    )->fetchField();
    $last_scan = max(array((int) $last_scan, REQUEST_TIME - PPGETSTAT_DEFAULT_TIME_PERIOD_FOR_SCANNING));

    if ($last_scan > REQUEST_TIME - 24 * 60 * 60) {
      continue;
    }

    $job = array(
      'generate_urls_callback' => '_ppgetstat_get_code_tracking_urls',
      'parse_pages_callback' => '_ppgetstat_parse_commits',
      'do_uid' => $doid,
      'last_scan' => $last_scan,
    );
    $queue->createItem($job);
  }

  variable_set('ppgetstat_last_statsjobs_timestamp', REQUEST_TIME);
}

/**
 * Process jobs from stats_jobs queue.
 */
function _ppgetstat_cron_processItem_stats_jobs() {
  $stats_jobs_queue = DrupalQueue::get('stats_jobs');
  $dorg_scrapping_queue = DrupalQueue::get('dorg_scrapping');
  for ($i = 0; $i < PPGETSTAT_STATSJOBS_PROCESS_NUMBER; $i++) {
    if ($stats_jobs_queue->numberOfItems() == 0) {
      break;
    }
    $item = $stats_jobs_queue->claimItem();
    if ($item == FALSE) {
      break;
    }

    $generate_urls_function = $item->data['generate_urls_callback'];
    if (!function_exists($generate_urls_function)) {
      watchdog('ppgetstat', 'generate_urls_callback ":generate_urls_callback" is not defined.', array(
        ':generate_urls_callback' => $generate_urls_function,
      ), WATCHDOG_ERROR);
      return;
    }
    $do_uid = $item->data['do_uid'];
    $last_scan = $item->data['last_scan'];
    foreach ($generate_urls_function($do_uid, $last_scan) as $url) {
      // We keep the id of the stats_jobs queue to group all dorg_scrapping jobs.
      $scrapping_job = array(
        'id' => $item->item_id,
        'url' => $url,
        'last_scan' => $last_scan,
        'do_uid' => $do_uid,
        'parse_pages_callback' => $item->data['parse_pages_callback'],
      );
      $dorg_scrapping_queue->createItem($scrapping_job);
    }

    $stats_jobs_queue->deleteItem($item);
  }
}

/**
 * Get all published user nodes.
 */
function _ppgetstats_get_all_users() {
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', PPGETSTAT_USER_NODE_TYPE)
    ->propertyCondition('status', 1)
    ->execute();
  if (!empty($result)) {
    $nids = array_keys($result['node']);
    return node_load_multiple($nids);
  }
  return array();
}

/**
 * Generate list of URLs for scanning the code.
 */
function _ppgetstat_get_code_tracking_urls($do_uid, $last_scan) {
  // In worst scenario we expect person to do one page (25 commits)
  // of commits every six hours.
  $days_number = round((REQUEST_TIME - $last_scan) / (6 * 60 * 60));
  $urls = array();
  for ($i = 0; $i < $days_number; $i++) {
    $urls[] = 'https://drupal.org/user/' . $do_uid . '/track/code?page=' . $i;
  }
  return $urls;
}

/**
 * Process jobs from dorg_scrapping queue.
 */
function _ppgetstat_cron_processItem_dorg_scrapping_jobs() {
  $dorg_scrapping_queue = DrupalQueue::get('dorg_scrapping');
  for ($i = 0; $i < PPGETSTAT_DORGSCRAPPING_PROCESS_NUMBER; $i++) {
    $queue_item = $dorg_scrapping_queue->claimItem();
    if ($queue_item == FALSE) {
      return;
    }

    $function = $queue_item->data['parse_pages_callback'];
    if (!function_exists($function)) {
      watchdog('ppgetstat', 'parse_pages_callback ":parse_pages_callback" is not defined.', array(
        ':parse_pages_callback' => $function,
      ), WATCHDOG_ERROR);
      return;
    }

    $page_content = _ppgetstat_fetch_page($queue_item->data['url']);

    try {
      $result = $function($page_content, $queue_item->data['do_uid'], $queue_item->data['last_scan']);
    }
    catch (Exception $e) {
      watchdog_exception('ppgetstat', $e);
      $result = 0;
    }

    if (empty($result)) {
      _ppgetstat_cleanup_dorg_scrapping_queue($queue_item->data['id']);
    }

    $dorg_scrapping_queue->deleteItem($queue_item);
  }
}

/**
 * Cleanup the dorg_scrapping queue.
 */
function _ppgetstat_cleanup_dorg_scrapping_queue($id) {
  $dorg_scrapping_queue = DrupalQueue::get('dorg_scrapping');
  while ($queue_item = $dorg_scrapping_queue->claimItem()) {
    if ($queue_item->data['id'] == $id) {
      $dorg_scrapping_queue->deleteItem($queue_item);
    }
    else {
      $dorg_scrapping_queue->releaseItem($queue_item);
      return;
    }
  }
}

/**
 * Retrieve content of the page.
 *
 * @param string $url
 *   URL of the page to retrieve.
 */
function _ppgetstat_fetch_page($url) {
  watchdog('_ppgetstat_fetch_page', $url);
  return file_get_contents($url);
}

/**
 * Parse the page for the commits.
 */
function _ppgetstat_parse_commits($page_content, $do_uid, $timestamp) {
  if (empty($page_content)) {
    throw new Exception('Empty page content.');
  }

  // Extract string with project name and date of the commit.
  // Example: <h3><a href="/project/apachesolr">Apache Solr Search</a>: <a href="/commitlog/commit/4838/9d8d6276d4246a0d2651b00bbd05786baa1324c9">October 7, 2013 20:40</a></h3>
  $strings = htmlqp($page_content, '.commit-global h3');

  if (empty($strings)) {
    throw new Exception(t('Page does not have any ".commit-global h3" elements.'));
  }

  $commits_counter_array = array();
  $commits_counter = 0;

  foreach ($strings as $string) {
    $commit_timestamp = _ppgetstat_parse_commits_page_date($string->html());

    if ($commit_timestamp < $timestamp) {
      break;
    }

    $period_timestamp = $commit_timestamp - ($commit_timestamp % PPGETSTAT_TIME_PERIOD_GRANULARITY);
    if (!isset($commits_counter_array[$period_timestamp])) {
      $commits_counter_array[$period_timestamp] = 0;
    }
    $commits_counter_array[$period_timestamp]++;
    $commits_counter++;
  }

  if ($commits_counter == 0) {
    return $commits_counter;
  }

  // SQL queries to update counters.
  $db_records = array();
  $periods = array_keys($commits_counter_array);
  $db_records = db_query('SELECT timestamp, commits FROM {ppgetstat_commits} WHERE doid = :doid AND timestamp IN (:periods)',
    array(':doid' => $do_uid, ':periods' => $periods)
  )->fetchCol();
  foreach ($commits_counter_array as $period => &$commits) {
    if (isset($db_records[$period])) {
      $commits += $db_records[$period];
      db_query('UPDATE {ppgetstat_commits} SET commits = :commits WHERE doid = :doid AND timestamp = :timestamp', array(
        array(
          ':commits' => $commits,
          ':doid' => $do_uid,
          ':timestamp' => $period,
        ),
      ));
    }
    else {
      $record = array(
        'doid' => $do_uid,
        'commits' => $commits,
        'timestamp' => $period,
      );
      drupal_write_record('ppgetstat_commits', $record);
    }
  }

  return $commits_counter;
}

/**
 * Parse string '<h3><a href="/project/apachesolr">Apache Solr Search</a>: <a href="/commitlog/commit/4838/9d8d6276d4246a0d2651b00bbd05786baa1324c9">October 7, 2013 20:40</a></h3>'.
 */
function _ppgetstat_parse_commits_page_date($original_string) {
  list(, $string) = explode('a>: <a href', $original_string);

  // Cut off remainig part of the link tag in the beginning.
  $string = substr($string, strpos($string, '>') + 1);
  // Remove "</a></h3>" from the end of the string.
  $string = substr($string, 0, strlen($string) - 9);

  $timestamp = strtotime($string);

  if (empty($timestamp)) {
    throw new Exception(t('Cannot parse string %string to timestamp.', array('%string' => $original_string)));
  }
  return $timestamp;
}

/**
 * Access callback for commits tab.
 */
function ppgetstat_commits_access($node) {
  return ($node->type == PPGETSTAT_USER_NODE_TYPE);
}
